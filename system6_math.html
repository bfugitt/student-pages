<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System 6 Math Facts - Fact Family</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

    <style>
        /* Base styling */
        body {
            font-family: 'VT323', monospace;
            background-color: #f0f0f0;
            color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            /* Use a tiling 1-bit pattern for the background, classic Mac style */
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(-45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, #ccc 75%), 
                              linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 4px 4px;
        }

        /* The main application window */
        .window {
            width: 100%;
            max-width: 420px;
            background-color: #fff;
            border: 2px solid #000;
            box-shadow: 6px 6px 0px #000;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
        }

        /* Modal Overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* Dim background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100; /* Sit on top */
            display: none; /* Hidden by default */
        }
        
        /* Higher z-index for the confirmation alert so it sits over other modals */
        #confirmation-modal {
            z-index: 200;
        }

        /* Modal Window Specifics */
        .modal-window {
            max-width: 500px; 
            box-shadow: 10px 10px 0px #000; 
        }
        
        /* Alert Window Specifics */
        .alert-window {
            max-width: 350px;
            box-shadow: 10px 10px 0px #000;
        }

        /* Title bar styling */
        .title-bar {
            background-color: #fff;
            border-bottom: 2px solid #000;
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        /* Stripes on the title bar */
        .title-bar-stripes {
            flex-grow: 1;
            background-image: repeating-linear-gradient(
                to bottom,
                #000,
                #000 2px,
                #fff 2px,
                #fff 4px
            );
            height: 14px;
            margin-left: 8px;
            margin-right: 8px;
        }

        /* Control Boxes (Close/Skip and Pause/Play) */
        .close-box, .pause-box {
            width: 18px;
            height: 18px;
            border: 2px solid #000;
            background: #fff;
            text-align: center;
            line-height: 14px;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
        }
        .close-box:active, .pause-box:active {
            box-shadow: 1px 1px 0px #000;
            transform: translate(1px, 1px);
        }
        /* Pause box styling */
        .pause-box {
            margin-left: 4px; 
            font-size: 14px;
            line-height: 16px;
        }

        /* Mode Selector Styling */
        .mode-selector {
            padding: 8px 16px;
            border-bottom: 2px solid #000;
            text-align: left;
            font-size: 18px;
            display: flex;
            align-items: center;
        }
        #game-mode {
            font-family: 'VT323', monospace;
            font-size: 18px;
            border: 2px solid #000;
            margin-left: 8px;
            padding: 2px;
            background-color: #fff;
            box-shadow: 1px 1px 0px #000;
        }


        /* Main content area */
        .content {
            padding: 16px;
            text-align: center;
            font-size: 24px;
            flex-grow: 1;
        }

        /* Problem display (for Fast Facts mode) */
        #problem-container {
            font-size: 64px;
            margin: 20px 0;
            height: 120px; 
            line-height: 120px;
            letter-spacing: 4px;
            transition: background-color 0.05s ease-out, color 0.05s ease-out; 
        }
        /* Style for the correction display */
        .correction-display {
            background-color: #000 !important; 
            color: #fff !important; 
            transition: none; 
        }

        /* --- Fact Triangle Styling --- */
        #triangle-container {
            position: relative; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 20px auto; 
            height: 160px; 
            font-size: 48px;
            line-height: 1.2;
            width: 100%; 
            max-width: 280px; 
            box-sizing: border-box;
        }
        
        /* Operation Symbol Styling - Centered in Triangle */
        #triangle-operator-symbol {
            position: absolute;
            top: 55%; 
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px; 
            font-weight: bold;
            opacity: 0.3; 
            color: #000;
            z-index: 0; 
            pointer-events: none;
            white-space: nowrap;
        }
        
        /* Fact Family Rows */
        #triangle-top-wrapper {
            margin-bottom: 20px; 
            z-index: 2; 
        }
        #triangle-bottom-row {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 0 30px; 
            box-sizing: border-box;
            z-index: 2; 
        }

        /* The circles */
        .number-circle {
            width: 70px; 
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #eee;
            border: 2px solid #000;
            border-radius: 50%; 
            box-sizing: border-box;
            font-size: 36px; 
            z-index: 2;
        }


        /* Input and Check Button Alignment */
        #input-controls {
            display: flex; 
            justify-content: center; 
            align-items: center; 
            gap: 10px;
        }

        /* Answer input field */
        #answer-input {
            font-family: 'VT323', monospace;
            font-size: 48px;
            width: 120px;
            text-align: center;
            border: 2px solid #000;
            padding: 5px;
            -moz-appearance: textfield;
        }
        #answer-input::-webkit-outer-spin-button,
        #answer-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Feedback message (Correct/Incorrect) */
        #feedback {
            font-size: 24px;
            height: 30px; 
            line-height: 30px;
            margin-top: 15px;
            font-weight: bold;
        }

        .feedback-correct {
            color: #000; 
        }
        .feedback-incorrect {
            color: #000; 
        }

        /* Info bar for score and timer */
        .info-bar {
            display: flex;
            justify-content: space-between;
            font-size: 20px;
            padding: 10px 16px;
            border-top: 2px solid #000;
        }

        /* Button styling */
        .button-bar {
            padding: 0 16px 16px;
            display: flex;
            justify-content: flex-end; 
            gap: 10px; /* Space between buttons */
        }
        .btn {
            font-family: 'VT323', monospace;
            font-size: 20px;
            background-color: #fff;
            border: 2px solid #000;
            padding: 5px 15px;
            box-shadow: 3px 3px 0px #000;
            cursor: pointer;
            user-select: none;
        }
        .btn:active {
            box-shadow: 1px 1px 0px #000;
            transform: translate(2px, 2px);
        }

        /* Weights display table */
        .weights-container {
            font-size: 18px;
            padding: 10px 16px 16px;
            border-top: 2px solid #000;
        }
        .weights-container h3 {
            margin: 0 0 10px;
            text-align: left;
            font-size: 22px;
        }
        #weights-table {
            width: 100%;
            border-collapse: collapse;
            text-align: center;
        }
        #weights-table th,
        #weights-table td {
            border: 1px solid #000;
            padding: 4px;
            font-size: 18px;
        }
        #weights-table th {
            background-color: #eee;
        }
        /* Highlight low weights */
        .weight-low {
            background-color: #c0ffc0; 
        }

        /* --- Log Table Specifics --- */
        #log-list-container {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #000;
            margin-bottom: 20px;
            padding: 5px;
            background: #fff;
        }
        #log-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 18px;
        }
        #log-table th, #log-table td {
            text-align: left;
            padding: 4px;
            border-bottom: 1px solid #ccc;
        }
        #log-table th {
            border-bottom: 2px solid #000;
        }

    </style>
</head>
<body>

    <!-- MODAL: Practice Log -->
    <div id="history-modal" class="modal-overlay">
        <div class="window modal-window">
            <div class="title-bar">
                <div class="close-box" id="modal-close-box">&times;</div>
                <div class="title-bar-stripes"></div>
                <div>Practice Log</div>
                <div class="title-bar-stripes"></div>
            </div>
            <div class="content" style="padding-bottom: 0;">
                <div id="log-list-container">
                    <table id="log-table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Time</th>
                                <th>Score</th>
                                <th>Duration</th>
                            </tr>
                        </thead>
                        <tbody id="log-table-body">
                            <!-- Logs injected here -->
                        </tbody>
                    </table>
                </div>
                <div style="margin-bottom: 15px; font-size: 18px;">
                    Select an action below:
                </div>
            </div>
            <div class="button-bar" style="justify-content: space-between; padding-top: 0;">
                <button class="btn" id="btn-continue">Continue</button>
                <button class="btn" id="btn-new-session">New Session</button>
                <button class="btn" id="btn-reset-all" style="background-color: #ffebeb;">Reset All</button>
            </div>
        </div>
    </div>

    <!-- MODAL: Confirmation Alert (New!) -->
    <div id="confirmation-modal" class="modal-overlay">
        <div class="window alert-window">
            <div class="title-bar">
                <div class="close-box" id="confirm-close-box">&times;</div>
                <div class="title-bar-stripes"></div>
                <div>Alert</div>
                <div class="title-bar-stripes"></div>
            </div>
            <div class="content">
                <div id="confirmation-message" style="margin-bottom: 20px;">
                    <!-- Message injected here -->
                </div>
                <div class="button-bar" style="justify-content: center; gap: 20px; padding: 0;">
                    <button class="btn" id="btn-confirm-yes">Yes</button>
                    <button class="btn" id="btn-confirm-cancel">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main application window --><div class="window">
        <!-- Title bar --><div class="title-bar">
            <!-- Close box now acts as a skip/cancel button (Left) --><div class="close-box" id="close-box-btn">&times;</div>
            <div class="title-bar-stripes"></div>
            <div>System 6 Math Facts</div>
            <div class="title-bar-stripes"></div>
            <!-- Pause/Play button (Right) --><div class="pause-box" id="pause-box-btn">||</div>
        </div>

        <!-- Mode Selector --><div class="mode-selector">
            <label for="game-mode">Mode:</label>
            <select id="game-mode">
                <option value="fastFacts">Fast Facts (A + B = ?)</option>
                <option value="factFamily">Fact Family (A?B?C Triangle)</option>
            </select>
        </div>

        <!-- Main content area --><div class="content">
            <!-- The math problem (Fast Facts Mode) --><div id="problem-container">
                7 &times; 6
            </div>
            
            <!-- Fact Family Triangle Display --><div id="triangle-container" style="display: none;">
                
                <!-- Large Operation Symbol (Centered) -->
                <div id="triangle-operator-symbol"></div> 

                <!-- Numbers -->
                <div class="triangle-row" id="triangle-top-wrapper">
                    <div class="number-circle" id="triangle-top"></div>
                </div>
                <div class="triangle-row" id="triangle-bottom-row">
                    <div class="number-circle" id="triangle-bottom-left"></div>
                    <div class="number-circle" id="triangle-bottom-right"></div>
                </div>
            </div>

            <!-- Input and new Check button container --><div id="input-controls">
                <!-- The answer input --><input type="number" id="answer-input" inputmode="numeric" pattern="[0-9]*">
                
                <!-- Manual Enter Button for mobile use --><button class="btn" id="check-answer-btn">Check</button>
            </div>

            <!-- Feedback message --><div id="feedback">
                Enter your answer and press Enter.
            </div>
        </div>

        <!-- Info bar (Score and Timer) --><div class="info-bar">
            <div id="score">Score: 0</div>
            <div id="total-time">Total Time: 00:00</div>
            <div id="timer">Time: 0.0s</div>
        </div>

        <!-- Button Bar --><div class="button-bar">
            <button class="btn" id="log-btn">Log Score</button>
            <button class="btn" id="reset-btn">Reset</button>
        </div>

        <!-- Weights Display --><div class="weights-container">
            <h3>Number Weights</h3>
            <table id="weights-table">
                <!-- Header will be built by JS --><thead>
                    <tr id="weights-header-row">
                        <th>Num</th>
                        <th>+ / -</th>
                        <th>&times; / &divide;</th>
                    </tr>
                </thead>
                <!-- Body will be built by JS --><tbody id="weights-body">
                    <!-- Rows will be added by JS --></tbody>
            </table>
        </div>
    </div>

    <script>
        // --- Constants ---
        const LOCAL_STORAGE_KEY = 'system6MathFactsState';
        const TIME_LIMIT_SECONDS = 3.0; 
        const INITIAL_OPERAND_WEIGHT = 5; 
        const WEIGHT_CHANGE_AMOUNT = 1;   
        const MIN_WEIGHT = 1;
        const MAX_WEIGHT = 10;
        const NEXT_PROBLEM_DELAY_MS = 300; // Updated to 300ms
        const CORRECTION_DISPLAY_DURATION_MS = 900; 

        // --- Game Range Settings ---
        const INITIAL_MIN_NUM = 2;
        const INITIAL_MAX_NUM = 9;
        const MASTER_MIN_NUM = 2;
        const MASTER_MAX_NUM = 20;

        // --- Game State Variables ---
        let currentScore = 0;
        let operandWeights = { addSub: {}, mulDiv: {} };
        let currentProblem = {};
        let lastProblemKey = ""; 
        let startTime = 0;
        let timerInterval = null; 
        let totalTimeSeconds = 0; 
        let totalTimeInterval = null; 
        let isPaused = false; 
        let currentMode = 'fastFacts'; 
        let practiceLogs = []; 
        
        // Variables for custom confirmation logic
        let pendingConfirmationAction = null;

        let minNumActive = INITIAL_MIN_NUM; 
        let maxNumAddSub = INITIAL_MAX_NUM;
        let maxNumMulDiv = INITIAL_MAX_NUM;

        // --- DOM Elements ---
        const problemContainer = document.getElementById('problem-container');
        const triangleContainer = document.getElementById('triangle-container'); 
        const answerInput = document.getElementById('answer-input');
        const feedback = document.getElementById('feedback');
        const scoreDisplay = document.getElementById('score');
        const timerDisplay = document.getElementById('timer');
        const resetBtn = document.getElementById('reset-btn'); 
        const logBtn = document.getElementById('log-btn'); 
        const weightsTableBody = document.getElementById('weights-body');
        const totalTimeDisplay = document.getElementById('total-time'); 
        const modeSelector = document.getElementById('game-mode'); 
        
        const checkAnswerBtn = document.getElementById('check-answer-btn');
        const closeBoxBtn = document.getElementById('close-box-btn');
        const pauseBoxBtn = document.getElementById('pause-box-btn'); 

        // --- Triangle specific elements ---
        const triangleTop = document.getElementById('triangle-top');
        const triangleBottomLeft = document.getElementById('triangle-bottom-left');
        const triangleBottomRight = document.getElementById('triangle-bottom-right');
        const triangleOperatorSymbol = document.getElementById('triangle-operator-symbol');

        // --- Modal Elements ---
        const historyModal = document.getElementById('history-modal');
        const modalCloseBox = document.getElementById('modal-close-box');
        const btnContinue = document.getElementById('btn-continue');
        const btnNewSession = document.getElementById('btn-new-session');
        const btnResetAll = document.getElementById('btn-reset-all');
        const logTableBody = document.getElementById('log-table-body');
        
        // --- Confirmation Modal Elements (NEW) ---
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationMessage = document.getElementById('confirmation-message');
        const btnConfirmYes = document.getElementById('btn-confirm-yes');
        const btnConfirmCancel = document.getElementById('btn-confirm-cancel');
        const confirmCloseBox = document.getElementById('confirm-close-box');


        // === Game Logic ===

        /**
         * Loads game state from localStorage or initializes a new game.
         */
        function loadGameState() {
            const savedState = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    currentScore = state.currentScore || 0;
                    minNumActive = state.minNumActive || INITIAL_MIN_NUM;
                    maxNumAddSub = Math.min(MASTER_MAX_NUM, state.maxNumAddSub || state.currentMaxNum || INITIAL_MAX_NUM);
                    maxNumMulDiv = Math.min(MASTER_MAX_NUM, state.maxNumMulDiv || state.currentMaxNum || INITIAL_MAX_NUM);
                    operandWeights = state.operandWeights;
                    lastProblemKey = state.lastProblemKey || "";
                    totalTimeSeconds = state.totalTimeSeconds || 0; 
                    currentMode = state.currentMode || 'fastFacts'; 
                    practiceLogs = state.practiceLogs || []; // Load logs
                    
                    ensureWeightsExist();
                } catch (e) {
                    console.error("Could not parse saved state, starting new game.", e);
                    initializeNewGame();
                }
            } else {
                initializeNewGame();
            }
            
            modeSelector.value = currentMode; 
            updateScoreDisplay();
            updateTotalTimeDisplay(); 
            updateWeightTable();
            startTotalTimeInterval(); 
            nextProblem();
        }
        
        /**
         * Sets up a brand new game state.
         */
        function initializeNewGame() {
            currentScore = 0;
            minNumActive = INITIAL_MIN_NUM;
            maxNumAddSub = INITIAL_MAX_NUM;
            maxNumMulDiv = INITIAL_MAX_NUM;
            operandWeights = { addSub: {}, mulDiv: {} };
            lastProblemKey = "";
            totalTimeSeconds = 0; 
            isPaused = false;
            currentMode = 'fastFacts'; 
            practiceLogs = [];
            ensureWeightsExist();
        }
        
        /**
         * Ensures that all numbers in the current active range (min to max)
         * have a weight entry.
         */
        function ensureWeightsExist() {
            for (let i = minNumActive; i <= maxNumAddSub; i++) {
                if (!operandWeights.addSub[i]) {
                    operandWeights.addSub[i] = INITIAL_OPERAND_WEIGHT;
                }
            }
            for (let i = minNumActive; i <= maxNumMulDiv; i++) {
                if (!operandWeights.mulDiv[i]) {
                    operandWeights.mulDiv[i] = INITIAL_OPERAND_WEIGHT;
                }
            }
        }

        /**
         * Saves the current game state to localStorage.
         */
        function saveGameState() {
            const state = {
                currentScore,
                minNumActive,
                maxNumAddSub,
                maxNumMulDiv,
                operandWeights,
                lastProblemKey,
                totalTimeSeconds,
                currentMode,
                practiceLogs
            };
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state));
        }

        // --- Logging and Reset Logic ---

        /**
         * Logs the current score and time, then shows the modal.
         */
        function logScore() {
            if (!isPaused) togglePause();

            const now = new Date();
            const logEntry = {
                date: now.toLocaleDateString(),
                time: now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                score: Math.floor(currentScore),
                duration: formatTime(totalTimeSeconds)
            };

            practiceLogs.unshift(logEntry);
            saveGameState(); 
            
            renderLogs();
            historyModal.style.display = 'flex'; 
        }

        function renderLogs() {
            logTableBody.innerHTML = '';
            practiceLogs.forEach(log => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${log.date}</td>
                    <td>${log.time}</td>
                    <td>${log.score}</td>
                    <td>${log.duration}</td>
                `;
                logTableBody.appendChild(row);
            });
        }

        // --- Custom Confirmation Logic ---

        function showConfirmation(message, onConfirmAction) {
            confirmationMessage.textContent = message;
            pendingConfirmationAction = onConfirmAction;
            confirmationModal.style.display = 'flex';
        }

        function hideConfirmation() {
            confirmationModal.style.display = 'none';
            pendingConfirmationAction = null;
        }

        // Confirmation Event Listeners
        btnConfirmYes.addEventListener('click', () => {
            if (pendingConfirmationAction) {
                pendingConfirmationAction();
            }
            hideConfirmation();
        });

        btnConfirmCancel.addEventListener('click', hideConfirmation);
        confirmCloseBox.addEventListener('click', hideConfirmation);


        /**
         * ACTIONS FROM LOG WINDOW
         */

        function actionContinue() {
            historyModal.style.display = 'none';
            if (isPaused) togglePause(); 
        }

        function actionNewSession() {
            stopTimerDisplay();
            stopTotalTimeInterval();

            currentScore = 0;
            totalTimeSeconds = 0;
            
            saveGameState();
            
            updateScoreDisplay();
            updateTotalTimeDisplay();
            historyModal.style.display = 'none';
            feedback.textContent = "New Session Started!";
            
            if (isPaused) {
                isPaused = false;
                pauseBoxBtn.textContent = '||';
                startTotalTimeInterval();
                nextProblem();
            } else {
                startTotalTimeInterval();
                nextProblem();
            }
        }

        function actionResetAll() {
            // Show custom modal on top of log modal
            showConfirmation("Are you sure you want to reset all scores and log entries?", () => {
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                initializeNewGame(); 
                saveGameState();     
                
                modeSelector.value = currentMode; 
                updateScoreDisplay();
                updateTotalTimeDisplay(); 
                updateWeightTable();
                
                historyModal.style.display = 'none';
                feedback.textContent = "Full Reset Complete.";
                
                if (isPaused) {
                    isPaused = false;
                    pauseBoxBtn.textContent = '||';
                }
                startTotalTimeInterval();
                nextProblem();
            });
        }

        /**
         * MAIN SCREEN RESET BUTTON
         * Resets session + weights/levels, BUT KEEPS LOGS
         */
        function resetGame() {
            stopTimerDisplay(); 
            stopTotalTimeInterval(); 
            
            // Use Custom Modal instead of confirm()
            showConfirmation("Are you sure? This will reset your level progress, score, and time.", () => {
                // Perform Soft Reset: Reset game state but preserve logs
                const existingLogs = [...practiceLogs]; 
                
                initializeNewGame(); 
                
                practiceLogs = existingLogs; // Restore logs
                
                saveGameState();
                modeSelector.value = currentMode;
                updateScoreDisplay();
                updateTotalTimeDisplay();
                updateWeightTable();
                feedback.textContent = "Progress reset.";
                feedback.className = '';
                
                startTotalTimeInterval();
                nextProblem();
            });
            
            // If they click cancel, we just need to ensure timers restart if they weren't paused
            // But since the modal is async, we handle restart in the "YES" block.
            // If they cancel, we might want to restart timers if they were running?
            // Let's add logic to restart timers if the confirmation is cancelled/closed.
            // Actually, simplest is to NOT stop timers until confirmed? 
            // Or just let them run in background. Let's let them run.
            if (!isPaused) {
                startTimerDisplay();
                startTotalTimeInterval();
            }
        }
        
        // --- End Logging Logic ---


        /**
         * Creates a weighted list from a weight object, filtering by the max allowed number.
         */
        function createWeightedList(weights, maxNum) {
            const list = [];
            for (let i = minNumActive; i <= maxNum; i++) {
                const weight = weights[i] || INITIAL_OPERAND_WEIGHT; 
                for (let j = 0; j < weight; j++) {
                    list.push(i.toString());
                }
            }
            return list;
        }

        /**
         * Selects a random item from a list.
         */
        function selectRandomFromList(list) {
            if (list.length === 0) return null;
            const index = Math.floor(Math.random() * list.length);
            return list[index];
        }

        /**
         * Updates the problem display based on the current mode.
         */
        function updateProblemDisplay() {
            // Clear any correction flash
            problemContainer.classList.remove('correction-display'); 
            problemContainer.textContent = ''; 

            // Clear symbol
            triangleOperatorSymbol.textContent = ''; 

            if (currentMode === 'factFamily' && currentProblem.triangle) {
                problemContainer.style.display = 'none';
                triangleContainer.style.display = 'flex';
                
                const { numA, numB, numC, missingIndex, isAddSub } = currentProblem.triangle;
                
                triangleTop.textContent = missingIndex === 2 ? '?' : numC;
                triangleBottomLeft.textContent = missingIndex === 0 ? '?' : numA;
                triangleBottomRight.textContent = missingIndex === 1 ? '?' : numB;

                // Set the large symbol
                triangleOperatorSymbol.textContent = isAddSub ? '+/-' : '×/÷';

            } else { // fastFacts (or fallback)
                problemContainer.style.display = 'block';
                triangleContainer.style.display = 'none';
                
                // Restore the original problem text
                problemContainer.textContent = `${currentProblem.num1} ${currentProblem.op} ${currentProblem.num2}`;
            }
        }

        /**
         * Generates the next math problem.
         */
        function nextProblem() {
            if (isPaused) return;

            let num1, num2, op;
            let validProblemFound = false;
            let attempts = 0;

            while (!validProblemFound && attempts < 15) {
                attempts++;
                
                if (currentMode === 'factFamily') {
                    // --- Fact Family Generation ---
                    const isAddSub = Math.random() < 0.5;
                    const maxNum = isAddSub ? maxNumAddSub : maxNumMulDiv;
                    const weightPool = createWeightedList(isAddSub ? operandWeights.addSub : operandWeights.mulDiv, maxNum);
                    
                    if (weightPool.length < 2) continue; 

                    let numA = parseInt(selectRandomFromList(weightPool));
                    let numB = parseInt(selectRandomFromList(weightPool));
                    let numC;

                    // Ensure numA and numB are always the smallest numbers (parts)
                    if (numA > numB) [numA, numB] = [numB, numA];

                    if (isAddSub) {
                        numC = numA + numB;
                        if (numC > MASTER_MAX_NUM * 2) continue; 
                    } else {
                        numC = numA * numB;
                        if (numC > 144) continue; 
                    }

                    const missingIndex = Math.floor(Math.random() * 3); // 0=A, 1=B, 2=C (The answer index)
                    
                    let baseOp, numMain, numSecondary, answerVal;

                    if (missingIndex === 0) {
                        // Missing A: C - B = A (or C / B = A)
                        baseOp = isAddSub ? '-' : '÷';
                        numMain = numC; numSecondary = numB; answerVal = numA;
                    } else if (missingIndex === 1) {
                        // Missing B: C - A = B (or C / A = B)
                        baseOp = isAddSub ? '-' : '÷';
                        numMain = numC; numSecondary = numA; answerVal = numB;
                    } else { 
                        // Missing C: A + B = C (or A * B = C)
                        baseOp = isAddSub ? '+' : 'x';
                        numMain = numA; numSecondary = numB; answerVal = numC;
                    }

                    currentProblem = { 
                        num1: numMain, 
                        num2: numSecondary, 
                        op: baseOp, 
                        answer: answerVal,
                        triangle: { numA, numB, numC, missingIndex, isAddSub }
                    };
                } 
                
                else {
                    // --- Fast Facts Generation (Existing Logic) ---
                    const operations = ['+', '-', 'x', '÷'];
                    op = operations[Math.floor(Math.random() * operations.length)];
                    
                    let weightPool, maxNum;
                    if (op === '+' || op === '-') {
                        maxNum = maxNumAddSub;
                        weightPool = createWeightedList(operandWeights.addSub, maxNum);
                    } else {
                        maxNum = maxNumMulDiv;
                        weightPool = createWeightedList(operandWeights.mulDiv, maxNum);
                    }
                    
                    if (weightPool.length === 0) continue;

                    num1 = parseInt(selectRandomFromList(weightPool));
                    num2 = parseInt(selectRandomFromList(weightPool));
                    
                    if (op === '÷') {
                        const product = num1 * num2;
                        if (product > 99 || product === 0 || num2 < minNumActive) continue; 
                        const answer = num1; 
                        num1 = product;
                        if(answer < minNumActive || answer > maxNum) continue; 
                        currentProblem = { num1, num2, op, answer };
                    } else if (op === '-') {
                        if (num1 < num2) [num1, num2] = [num2, num1]; 
                        currentProblem = { num1, num2, op, answer: num1 - num2 };
                    } else if (op === '+') {
                        currentProblem = { num1, num2, op, answer: num1 + num2 };
                    } else if (op === 'x') {
                        currentProblem = { num1, num2, op, answer: num1 * num2 };
                    }
                }
                
                const tempKey = `${currentProblem.num1}${currentProblem.op}${currentProblem.num2}`;
                if (tempKey !== lastProblemKey) {
                    validProblemFound = true;
                }
            }
            
            if (!currentProblem.op) {
                 // Fallback problem if generation failed (e.g., empty weight pools)
                 currentProblem = { num1: 2, num2: 2, op: '+', answer: 4, triangle: null };
            }

            lastProblemKey = `${currentProblem.num1}${currentProblem.op}${currentProblem.num2}`;

            updateProblemDisplay(); 
            
            answerInput.value = '';
            answerInput.focus();
            
            startTimerDisplay();
            startTime = Date.now();
        }

        /**
         * Checks the user's answer.
         */
        function checkAnswer() {
            if (isPaused) return;
            
            stopTimerDisplay();
            const answerTime = (Date.now() - startTime) / 1000.0;
            const userAnswer = parseInt(answerInput.value);

            if (isNaN(userAnswer)) {
                feedback.textContent = "Please enter a number.";
                feedback.className = 'feedback-incorrect';
                startTimerDisplay(); 
                return;
            }

            const isCorrect = (userAnswer === currentProblem.answer);
            const isFast = (answerTime <= TIME_LIMIT_SECONDS);
            
            // Base score for fact family is based on the components (numA + numB)
            const baseScore = currentMode === 'factFamily' 
                ? (currentProblem.triangle.numA + currentProblem.triangle.numB) / 2
                : (currentProblem.num1 + currentProblem.num2) / 2;

            let scoreChange = 0;

            if (isCorrect) {
                if (isFast) {
                    feedback.textContent = `Correct! (${answerTime.toFixed(1)}s)`;
                    feedback.className = 'feedback-correct';
                    scoreChange = Math.max(2, baseScore); 
                    adjustWeights(currentProblem, false); // Decrease weight
                } else {
                    feedback.textContent = `Correct, but slow. (${answerTime.toFixed(1)}s)`;
                    feedback.className = 'feedback-correct';
                    scoreChange = Math.max(1, baseScore / 2); 
                }
            } else {
                feedback.textContent = `Incorrect. The answer was ${currentProblem.answer}.`;
                feedback.className = 'feedback-incorrect';
                scoreChange = -Math.max(1, baseScore / 4); 
                adjustWeights(currentProblem, true); // Increase weight
            }

            currentScore = Math.max(0, currentScore + scoreChange);
            updateScoreDisplay();
            
            const opType = (currentProblem.op === '+' || currentProblem.op === '-') ? 'addSub' : 'mulDiv';
            checkMaxNumProgression(opType);

            updateWeightTable();
            saveGameState();
            
            if (isCorrect) {
                setTimeout(nextProblem, NEXT_PROBLEM_DELAY_MS); 
            } else {
                displayCorrection(currentProblem);
            }
        }
        
        /**
         * Displays the correct answer as a black box with white text.
         */
        function displayCorrection(problem) {
            
            let correctEquation;
            if (currentMode === 'factFamily' && problem.triangle) {
                const { numA, numB, numC } = problem.triangle;
                
                // For fact family, we use the original problem container to flash the full equation
                correctEquation = `${numA} ${problem.triangle.isAddSub ? '+' : '×'} ${numB} = ${numC}`;
            } else {
                correctEquation = `${problem.num1} ${problem.op} ${problem.num2} = ${problem.answer}`;
            }
            
            answerInput.disabled = true;
            answerInput.blur();

            // Temporarily use the fast facts container for the black-box flash
            const flashTarget = document.getElementById('problem-container');
            
            flashTarget.style.display = 'block';
            document.getElementById('triangle-container').style.display = 'none';

            flashTarget.classList.add('correction-display');
            flashTarget.textContent = correctEquation;


            setTimeout(() => {
                flashTarget.classList.remove('correction-display');
                answerInput.disabled = false;
                
                setTimeout(nextProblem, NEXT_PROBLEM_DELAY_MS);
            }, CORRECTION_DISPLAY_DURATION_MS);
        }

        /**
         * Adjusts the weights for the problem and its operands.
         */
        function adjustWeights(problem, increase) {
            const change = increase ? WEIGHT_CHANGE_AMOUNT : -WEIGHT_CHANGE_AMOUNT;
            let weightsToAdjust = [];
            let weightPool;
            let opType;

            if (currentMode === 'factFamily' && problem.triangle) {
                // Fact Family: Adjust weights of the two parts (numA and numB)
                const { numA, numB, isAddSub } = problem.triangle;
                opType = isAddSub ? 'addSub' : 'mulDiv';
                weightPool = isAddSub ? operandWeights.addSub : operandWeights.mulDiv;
                weightsToAdjust = [numA, numB];
            } else {
                // Fast Facts: Adjust weights of the two operands (num1 and num2)
                const { num1, num2, op, answer } = problem;
                opType = (op === '+' || op === '-') ? 'addSub' : 'mulDiv';
                weightPool = opType === 'addSub' ? operandWeights.addSub : operandWeights.mulDiv;
                weightsToAdjust = [num1, num2];
                
                // For division, the result (answer) is also a factor
                if (op === '÷') {
                    weightsToAdjust.push(answer);
                }
            }

            // Apply adjustment to the relevant numbers
            weightsToAdjust.forEach(num => {
                if (num >= MASTER_MIN_NUM && num <= MASTER_MAX_NUM) {
                     if (weightPool[num] !== undefined) {
                         weightPool[num] = Math.max(MIN_WEIGHT, Math.min(MAX_WEIGHT, weightPool[num] + change));
                     }
                }
            });
        }
        
        /**
         * Checks if the max number for an operation type should be increased (leveled up).
         */
        function checkMaxNumProgression(operationType) {
            const isAddSub = (operationType === 'addSub');
            let currentMax = isAddSub ? maxNumAddSub : maxNumMulDiv;
            const weightPool = isAddSub ? operandWeights.addSub : operandWeights.mulDiv;
            
            if (currentMax < MASTER_MAX_NUM && weightPool[currentMax] === MIN_WEIGHT) {
                
                currentMax++;
                
                if (isAddSub) {
                    maxNumAddSub = currentMax;
                } else {
                    maxNumMulDiv = currentMax;
                }
                
                ensureWeightsExist();
                
                feedback.textContent = `Level Up! Unlocked facts for ${currentMax} in ${operationType === 'addSub' ? 'Add/Sub' : 'Mult/Div'}!`;
                feedback.className = 'feedback-correct';
                
                return true;
            }
            return false;
        }

        // === UI Functions (Timer and Display) ===

        function startTimerDisplay() {
            stopTimerDisplay(); 
            timerInterval = setInterval(() => {
                const elapsed = (Date.now() - startTime) / 1000.0;
                timerDisplay.textContent = `Time: ${elapsed.toFixed(1)}s`;
            }, 100);
        }

        function stopTimerDisplay() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }
        
        function startTotalTimeInterval() {
            if (!totalTimeInterval) {
                totalTimeInterval = setInterval(() => {
                    totalTimeSeconds++;
                    updateTotalTimeDisplay();
                }, 1000); 
            }
        }

        function stopTotalTimeInterval() {
            if (totalTimeInterval) {
                clearInterval(totalTimeInterval);
                totalTimeInterval = null;
            }
            saveGameState(); // Save state when stopping total time (e.g., on pause/exit)
        }
        
        function formatTime(totalSec) {
            const minutes = Math.floor(totalSec / 60);
            const seconds = totalSec % 60;
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(seconds).padStart(2, '0');
            return `${formattedMinutes}:${formattedSeconds}`;
        }

        function updateTotalTimeDisplay() {
            totalTimeDisplay.textContent = `Total Time: ${formatTime(totalTimeSeconds)}`;
        }

        function updateScoreDisplay() {
            scoreDisplay.textContent = `Score: ${Math.floor(currentScore)}`;
        }

        function updateWeightTable() {
            const overallMax = Math.max(maxNumAddSub, maxNumMulDiv);
            const weightsHeaderRow = document.getElementById('weights-header-row');
            
            weightsHeaderRow.innerHTML = `
                <th>Num</th>
                <th>+ / -</th>
                <th>&times; / &divide;</th>
            `;
            weightsTableBody.innerHTML = ""; 

            for (let i = minNumActive; i <= overallMax; i++) {
                const row = document.createElement('tr');
                const addSubActive = i <= maxNumAddSub;
                const mulDivActive = i <= maxNumMulDiv;

                const addSubWeight = addSubActive ? (operandWeights.addSub[i] || INITIAL_OPERAND_WEIGHT) : 'N/A';
                const mulDivWeight = mulDivActive ? (operandWeights.mulDiv[i] || INITIAL_OPERAND_WEIGHT) : 'N/A';
                
                const addSubClass = addSubActive && addSubWeight === MIN_WEIGHT ? 'weight-low' : '';
                const mulDivClass = mulDivActive && mulDivWeight === MIN_WEIGHT ? 'weight-low' : '';


                row.innerHTML = `
                    <td>${i}</td>
                    <td class="${addSubClass}">${addSubWeight}</td>
                    <td class="${mulDivClass}">${mulDivWeight}</td>
                `;
                weightsTableBody.appendChild(row);
            }
        }

        // === Event Listeners ===
        
        answerInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                checkAnswer();
            }
        });
        
        checkAnswerBtn.addEventListener('click', checkAnswer);
        closeBoxBtn.addEventListener('click', cancelProblem);
        pauseBoxBtn.addEventListener('click', togglePause);
        resetBtn.addEventListener('click', resetGame);
        logBtn.addEventListener('click', logScore); // New Log Listener

        // Modal Listeners
        btnContinue.addEventListener('click', actionContinue);
        btnNewSession.addEventListener('click', actionNewSession);
        btnResetAll.addEventListener('click', actionResetAll);
        modalCloseBox.addEventListener('click', actionContinue);
        
        // Confirmation Modal Listeners
        btnConfirmYes.addEventListener('click', () => {
            if (pendingConfirmationAction) pendingConfirmationAction();
            hideConfirmation();
        });
        btnConfirmCancel.addEventListener('click', hideConfirmation);
        confirmCloseBox.addEventListener('click', hideConfirmation);
        
        // Mode change listener
        modeSelector.addEventListener('change', (e) => {
            if (isPaused) return; 
            currentMode = e.target.value;
            saveGameState(); 
            nextProblem();    
        });

        // Toggle pause function 
        function togglePause() {
            if (isPaused) {
                isPaused = false;
                pauseBoxBtn.textContent = '||';
                startTotalTimeInterval(); 
                updateTotalTimeDisplay(); 
                feedback.textContent = "Resumed. Get ready!";
                feedback.className = '';
                setTimeout(nextProblem, 50); 
            } else {
                isPaused = true;
                stopTimerDisplay(); 
                stopTotalTimeInterval(); 
                
                // Ensure fast facts container is used for the pause message
                document.getElementById('problem-container').style.display = 'block'; 
                document.getElementById('triangle-container').style.display = 'none';
                problemContainer.textContent = '- PAUSED -';
                problemContainer.classList.remove('correction-display');
                
                answerInput.value = '';
                answerInput.blur();
                
                pauseBoxBtn.textContent = '▶';
                feedback.textContent = "Game Paused";
                feedback.className = '';
                timerDisplay.textContent = "Time: PAUSED";
                totalTimeDisplay.textContent = 'Total Time: PAUSED';
            }
        }
        
        function cancelProblem() {
            if (isPaused) return;

            stopTimerDisplay();
            answerInput.value = '';
            feedback.textContent = "Problem skipped. Loading next one...";
            feedback.className = '';
            
            nextProblem();
        }


        // --- Start the app ---
        window.addEventListener('beforeunload', saveGameState); // Attempt to save on closing
        loadGameState();

    </script>
</body>
</html>
